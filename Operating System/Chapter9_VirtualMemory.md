가상 메모리
===========

# 1. 가상 메모리

프로그램을 일부만 메모리에 적재하고도 실행이 가능하게 하는 기법
이를 통해 멀티프로그래밍, CPU 이용률, 처리량 ↑ 그리고 swaping 시간 ↓ , page 공유를 통해 process 생성 시간 단축

# 2. 요구 페이징

page가 실제 필요할 때 메모리에 적재하는 것

## Page Fault(페이지 부재)

메모리에 적재 되지 않은 page를 참조 할시 발생하는 문제이다. Page Fault의 처리 과정은 다음과 같다. 

    1. 명령어 시작
    2. 페이지 참조
    3. 페이지 부재 발생
    4. 보조 저장 장치에서 요구되는 페이지를 메모리에 적재한뒤 페이지 테이블을 갱신
    5. 명령어 재시작

# 3. 페이지 교체

페이지 부재시 남아있는 frame이 없는 경우 페이지 교체가 필요하다.

## 페이지 교체 알고리즘

1. FIFO(First  In First Out)

가장 먼저 적재된 페이지를 제거하고 새로운 페이지를 적재한다.

장점 : 구현이 쉽다.

단점 : 성능이 항상 좋지는 않으며 frame의 수가 증가해도 페이지 부재율이 증가하는 경우가 생긴다.

2. 최적

앞으로 가장 오랫동안 사용되지 않을 페이지를 제거하고 새로운 페이지를 적재한다.

장점 : frame 수가 고정된 경우 가장 낮은 페이지 부재율을 보장한다.

단점 : 오랫동안 사용되지 않을 페이지를 알아내야 하므로 구현이 어렵다.

3. LRU(Least Recently Used Page)

가장 오래 전에 사용된 페이지를 제거하고 새로운 페이지를 적재한다.

장점 : 여러 OS에서 사용되며, 페이지 부재율은 최적과 FIFO사이에 있어서 좋은 알고리즘을 간주된다. 

단점 : 각 페이지마다 마지막 사용 시각을 유지하여야 하므로 H/W의 지원이 필요하다. 이는 Counter나 Stack을 통해 유지 한다.

Counter는 페이지 참조할 때 마다 마지막 사용 시각(현재 + 1)이 설정된다. 그러므로 페이지 교체가 필요할 시 마지막 사용 시각이 가장 작은 페이지가 교체된다.

Stack은 새로운 페이지 참조시 push하고 페이지 부재시 pop을 하여 제거될 페이지를 가져온다.

4. LRU 근사

LRU의 문제점인 사용 시각을 체크할 Counter나 Stack의 구현 점을 보완한다. 

    1. 추가 참조 비트 알고리즘

    2. 이차 기회 알고리즘

    페이지 부재가 발생시 큐에서 나갈 페이지의 참조비트가 0이면 사용되지 않은 페이지이므로 바로 제거하고 참조비트가 1이면 사용되었던 페이지이므로 한번의 기회를 더 부여하여 참조비트를 0으로 변경한뒤 큐의 맨뒤로 이동시킨다.
    
    3. 개선된 이차 기회 알고리즘

    참조비트와 변경비트를 이용하여 페이지에 등급을 부여한다. 이중 등급이 등급(우선순위)가 가장 낮은 페이지를 제거한다.

    우선순위

    낮음    (0,0) : 최근 사용x, 변경x
            (0,1) : 교체시 disk write 필요 
            (1,0) : 조만간 다시 사용될 가능성 높음
    높음    (1,1) : 최근 사용, 변경 됨

5. 계수 기반 페이지 교체

각 페이지의 참조 횟수에 기반한 알고리즘

    1. LFU(Least Frequently Used)

    문제점 : 가장 적게 참조된 페이지를 제거하므로 당장 필요없는 페이지는 페이지 테이블에서 자리를 차지하게 된다.

    2. MFU(Most Frequently Used)

    문제점 : 가장 많이 참조된 페이지를 제거하므로 당장 필요없는 페이지는 페이지 테이블에서 자리를 차지하게 된다.

6. 페이지 버퍼링

페이지 부재가 발생하면 페이지를 free frame pool로 읽어와 실행을 하고 이후에 희생될 페이지를 찾아 제거한다. 희생된 페이지가 사용하던 frame은 pool에 추가된다.

# 4. 프레임 할당

프로세스에 할당된 프레임의 수가 적으면 페이지 부재율이 증가한다. 이를 방지하기 위해 프로세스마다 최적의 프레임 개수를 지정 해줘야한다. 

## 프레임 할당 알고리즘

1. 균등 할당

모든 프로세스에게 균등한 프레임을 할당한다.

2. 비례할당

프로세스 크기에 비례하여 프레임을 할당한다.

3. 우선순위 할당

프로세스의 우선순위에 비례하여 프레임을 할당한다.

## 지역할당과 전역할당

지역할당은 페이지 부재가 발생할 시 해당 프로세스에 할당된 프레임 내에서 페이지를 교체하는 것이다.
전역할당은 페이지 부재가 발생할 시 해당 프로세스와 다른 프로세스에 할당된 프레임에서 페이지를 교체하는 것이다.

# 5. Thrashing

한정된 프레임에서 페이지 부재가 발생하여 페이지를 교체하였으나 제거된 페이지가 다시 참조를 하여 페이지 부재가 발생하는 악순환을 Thrashing이라 한다.

## Thrashing 예방

1. 작업 집합 모델

Thrashing이 일어나지 않도록 프로세스가 필요로 하는 만큼의 프레임을 할당한다.

2. 페이지 부재 빈도

페이지 부재율을 관찰하고 이에 따라 프로세스의 프레임 수를 조절한다.

# 6. 메모리 사상 파일
가상메모리 기법을 file/IO에 적용한 기법

## 동작원리

1. 파일을 process의 페이지에 사상한다.

2. 최초 파일 접근시 페이지 부재가 발생되며 이때 disk block을 페이지로 읽어온다.

3. 차후 모든 file I/O는 memory R/W로 대신된다.

4. 변경된 page는 주기적 또는 close() 호출 시 실제 디스크에 write 된다. 

# 7. Kernel Memory 할당

1. Buddy System

요청된 크기의 메모리를 얻을 때 까지 segment를 두개로 분할 한다. 이때 분할된 segment를 Buddy라고 한다. 메모리를 반환하면 분할된 Buddy를 합병한다.

단점 : 128kb가 남아있는 메모리에서 21kb를 요청할 경우 128kb → 64kb + 64kb → 32kb + 32kb + 32kb + 32kb 에서 32kb에 21kb를 할당하므로 나머지 공간인 11kb는 낭비가 된다. 즉 내부 단편화가 발생한다.

2. Slab Allocation
왜 필요한가? 

빈번하게 발생되는 영역 즉, Process Descriptor와 open file object 같은것들은 생성과 소멸이 매우 빈번한대 이런거 처리할 때 slab allocator는 빠르게 처리한다.

객체를 만들어서 관리하는데, 이때 Slab allocator는 이러한 객체들은 절대로 discard 하지 않기 때문에 reinitialized 하는 overhead를 초래하지 않는다.

classified 한 요청은 결국 frequency를 가진다. 따라서 high grequency는 미리 만들어서 to avoid internal fragmentation하고, rarely used object는 power of 2 size 정책을 이용해서 할당한다.(2.0 방식 이용)
